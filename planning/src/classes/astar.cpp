#include <astar.h>
#include <nav_msgs/OccupancyGrid.h>
#include <nav_msgs/Path.h>
#include <geometry_msgs/PoseStamped.h>
#include <queue>

#include <algorithm>
#include <unordered_map>
#include <math.h>
#include <string>
#include <set>

using geometry_msgs::Point;
using geometry_msgs::PoseStamped;
using nav_msgs::Path;

geometry_msgs::Point point;

#define RVIZ_COMPATABILITY

Point get_point(double x, double y)
{
  // ROS should really add constructors...
  Point p;
  p.x = x;
  p.y = y;
  return p;
}

double distance(int ind1, int ind2, int width)
{
  // Return Euclidean Distance.
  auto pt1 = std::make_pair<int, int>(ind1 % width, (int)floor(ind1 / width));
  auto pt2 = std::make_pair<int, int>(ind2 % width, (int)floor(ind2 / width));
  return sqrt((pt1.first - pt2.first) * (pt1.first - pt2.first) + (pt1.second - pt2.second) * (pt1.second - pt2.second));
}

std::array<int, 8> get_neighbors_indicies_array(int pt, int widthOfGrid, int sizeOfGrid)
{
  std::array<int, 8> neighbors;

  neighbors[0] = ((pt + 1) < 0) || ((pt + 1) > sizeOfGrid) ? -1 : pt + 1;
  neighbors[1] = ((pt - 1) < 0) || ((pt - 1) > sizeOfGrid) ? -1 : pt - 1;
  neighbors[2] = ((pt + widthOfGrid) < 0) || ((pt + widthOfGrid) > sizeOfGrid) ? -1 : pt + widthOfGrid;
  neighbors[3] = ((pt + widthOfGrid + 1) < 0) || !((pt + widthOfGrid + 1) > sizeOfGrid) ? -1 : pt + widthOfGrid + 1;
  neighbors[4] = ((pt + widthOfGrid - 1) < 0) || !((pt + widthOfGrid - 1) > sizeOfGrid) ? -1 : pt + widthOfGrid - 1;
  neighbors[5] = ((pt - widthOfGrid) < 0) || !((pt - widthOfGrid) > sizeOfGrid) ? -1 : pt - widthOfGrid;
  neighbors[6] = ((pt - widthOfGrid + 1) < 0) || !((pt - widthOfGrid + 1) > sizeOfGrid) ? -1 : pt - widthOfGrid + 1;
  neighbors[7] = ((pt - widthOfGrid - 1) < 0) || !((pt - widthOfGrid - 1) > sizeOfGrid) ? -1 : pt - widthOfGrid - 1;

  return neighbors;
}

inline bool collinear(int pt1, int pt2, int pt3, int width)
{
  // Checks if three points lie on the same line.
  int pt1x = pt1 % width;
  int pt1y = (int)floor(pt1 / width);

  int pt2x = pt2 % width;
  int pt2y = (int)floor(pt2 / width);

  int pt3x = pt3 % width;
  int pt3y = (int)floor(pt3 / width);

  return (pt2y - pt1y) * (pt3x - pt2x) == (pt3y - pt2y) * (pt2x - pt1x);
}

PoseStamped posestamped_from_index(int ind, std::string frame_id, int width)
{
  // Helper function to turn a grid index into a posedstamped point.
  double indx = ind % width;
  double indy = floor(ind / width);

  PoseStamped ps;

#ifdef RVIZ_COMPATABILITY
  ps.pose.position.x = indx / 20;
  ps.pose.position.y = indy / 20;
#else
  ps.pose.position.x = indx;
  ps.pose.position.y = indy;
#endif

  printf("%f, %f\n", indx / 20, indy / 20);

  ps.header.frame_id = frame_id;
  return ps;
}

Path reconstruct_path(int current, int last, std::unordered_map<int, int> &reverse_list, std::string frame_id, int width)
{
  // This function takes the list of nodes generated by A* and converts it into a list of waypoints.
  // It does this by taking the last point and retracing its steps back to the starting point
  // It also removes any collinear points.

  Path p;
  PoseStamped lastPs = posestamped_from_index(last, frame_id, width);
  PoseStamped firstPs = posestamped_from_index(current, frame_id, width);
  p.poses.push_back(firstPs);
  int lastPt = current;
  current = reverse_list[current];

  p.header.frame_id = frame_id;

  while (current != -1)
  {
    if (!collinear(lastPt, current, reverse_list[current], width))
      p.poses.push_back(posestamped_from_index(current, frame_id, width));

    lastPt = current;
    current = reverse_list[current];
  }

  p.poses.push_back(lastPs);
  return p;
}

Path AStar::FindPathOccGrid(nav_msgs::OccupancyGrid oGrid, Point target, Point start)
{
  // A Star Implementation based off https://en.wikipedia.org/wiki/A*_search_algorithm

  std::vector<double> gScores(oGrid.data.size(), INFINITY);

  int endIndex = target.y * oGrid.info.width + target.x;
  int startIndex = start.y * oGrid.info.width + start.x;

  auto origin = std::make_pair<double, int>(0, std::move(startIndex));

  std::set<std::pair<double, int>> open_set;
  open_set.insert(origin);

  std::unordered_map<int, int> came_from;
  came_from[startIndex] = -1;

  gScores[start.y * oGrid.info.width + start.x] = 0;

  while (!open_set.empty())
  {
    auto iter = open_set.lower_bound(std::make_pair<double, int>(0, 0));
    auto current = *iter;
    open_set.erase(iter);

    if (current.second == endIndex)
    {
      return reconstruct_path(current.second, startIndex, came_from, oGrid.header.frame_id.c_str(), oGrid.info.width);
    }

    if (oGrid.data[current.second] >= 50)
      continue;

    for (int neighbor : get_neighbors_indicies_array(current.second, oGrid.info.width, oGrid.data.size()))
    {
      if (neighbor == -1)
        continue;

      double tentative_gscore = gScores[current.second] + distance(current.second, neighbor, oGrid.info.width);
      if (tentative_gscore < gScores[neighbor])
      {
        gScores[neighbor] = tentative_gscore;
        came_from[neighbor] = current.second;
        open_set.insert(std::make_pair<double, int>((tentative_gscore + distance(neighbor, endIndex, oGrid.info.width)), std::move(neighbor)));
      }
    }
  }

  printf("[WARNING] Call to navigation failed to find valid path.\n");
  return Path();
}